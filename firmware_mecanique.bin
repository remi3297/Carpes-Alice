#include <Arduino.h>
#include <ArduinoJson.h>
#include <HTTPClient.h>
#include <WiFi.h>
#include <Update.h>

#include "USB.h"
#include "USBCDC.h"
#include "driver/ledc.h"

// Définitions matérielles
#define LED 7
#define H1 6
#define H2 5
#define SLEEP 4

// Définitions PWM
#define LEDC_RESOLUTION 4 // 4 bits resolution
#define LEDC_MODE 0
#define LEDC_DUTY 0          // Duty cycle set to 0%
#define LEDC_FREQUENCY 250000  // Frequency set to 250 kHz

// Signature obligatoire pour les mises à jour (sécurité) - DOIT ÊTRE PRÉSENTE
const char* UPDATE_SIGNATURE = "CARPE_UPDATE_VALID_V1";

// Version du firmware mise à jour
#define CURRENT_VERSION "1.1.0"

// URLs pour la mise à jour
const char* VERSION_URL = "http://raw.githack.com/remi3297/Carpes-Alice/main/version.json";
const char* FIRMWARE_URL = "https://cdn.statically.io/gh/remi3297/Carpes-Alice/main/firmware_mecanique.bin";

// Ajout d'une String persistante pour stocker l'URL du firmware
String firmwareUrlString = "";

// Variables globales
HWCDC cdc;
unsigned long previousMillis = 0;
const long moveInterval = 1000; // 1 mouvement toutes les secondes (mouvement mécanique)
unsigned long lastUpdateCheck = 0;
const long updateInterval = 60000; // vérifier mise à jour toutes les minutes
bool updateAvailable = false;
bool wifiConnected = false;

// Prototypes
void moveMechanical();
void checkForUpdates();
bool downloadAndInstallUpdate();

void setup() {
  // Configuration des pins
  pinMode(LED, OUTPUT);
  pinMode(H1, OUTPUT);
  pinMode(H2, OUTPUT);
  pinMode(SLEEP, OUTPUT);
  digitalWrite(SLEEP, LOW);

  // Initialisation communication
  cdc.begin(460800);
  delay(2000);
  cdc.println("Carpe v" CURRENT_VERSION " starting...");
  cdc.println("MOUVEMENT MÉCANIQUE ACTIVÉ - TEST DE MISE À JOUR RÉUSSI");

  // Configuration des canaux PWM
  ledcSetup(LEDC_CHANNEL_0, LEDC_FREQUENCY, LEDC_RESOLUTION);
  ledcAttachPin(H1, LEDC_CHANNEL_0);
  ledcSetup(LEDC_CHANNEL_1, LEDC_FREQUENCY, LEDC_RESOLUTION);
  ledcAttachPin(H2, LEDC_CHANNEL_1);

  // Signal de démarrage
  for (uint8_t i = 0; i < 10; i++) {
    digitalWrite(LED, !digitalRead(LED));
    delay(100);
  }

  // Connexion WiFi (non bloquante)
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  cdc.print("Connecting to WiFi...");

  // Attendre la connexion WiFi (max 10 secondes)
  uint8_t attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 20) {
    delay(500);
    cdc.print(".");
    attempts++;
  }

  if (WiFi.status() == WL_CONNECTED) {
    wifiConnected = true;
    cdc.println("WiFi Connected!");
    cdc.print("IP address: ");
    cdc.println(WiFi.localIP().toString());
  } else {
    cdc.println("WiFi Failed! Running in offline mode.");
  }

  digitalWrite(SLEEP, HIGH);
  previousMillis = millis();
  lastUpdateCheck = millis();
}

void loop() {
  unsigned long currentMillis = millis();

  // Vérifier les mises à jour si WiFi connecté
  if (wifiConnected && (currentMillis - lastUpdateCheck >= updateInterval)) {
    lastUpdateCheck = currentMillis;
    cdc.println("Checking for updates...");
    checkForUpdates();

    if (updateAvailable) {
      cdc.println("Update available! Downloading...");
      // Télécharger et installer pendant que la carpe continue à bouger
      if (downloadAndInstallUpdate()) {
        cdc.println("Update successful! Restarting...");
        delay(1000);
        ESP.restart();
      } else {
        cdc.println("Update failed!");
        updateAvailable = false;
      }
    }
  }

  // Mouvement MÉCANIQUE (1 par seconde)
  if (currentMillis - previousMillis >= moveInterval) {
    previousMillis = currentMillis;
    moveMechanical();
  }

  // Retenter la connexion WiFi périodiquement si déconnecté
  if (!wifiConnected && (currentMillis % 300000) < 10) { // Toutes les 5 minutes
    WiFi.begin(WIFI_SSID, WIFI_PASS);
    delay(5000);
    wifiConnected = (WiFi.status() == WL_CONNECTED);
    if (wifiConnected) {
      cdc.println("WiFi reconnected!");
    }
  }
}

// Fonction de mouvement MÉCANIQUE (1 par seconde)
void moveMechanical() {
  const uint8_t mappedValue = 14;  // Même valeur fixe
  cdc.println("mechanical move");

  // Un seul cycle de mouvement précis
  digitalWrite(H2, LOW);  // clockwise
  digitalWrite(LED, HIGH);
  digitalWrite(SLEEP, HIGH);
  
  // Accélération rapide
  for (uint8_t j = 0; j < mappedValue; j++) {
    ledcWrite(LEDC_CHANNEL_0, j);
    delay(10);  // Accélération plus rapide
  }
  
  delay(50);  // Courte pause
  
  // Décélération rapide
  for (uint8_t j = mappedValue; j > 0; j--) {
    ledcWrite(LEDC_CHANNEL_0, j);
    delay(10);  // Décélération plus rapide
  }
  
  digitalWrite(SLEEP, LOW);
  delay(100);  // Pause courte

  // Mouvement inverse
  digitalWrite(H1, LOW); // counter clockwise
  digitalWrite(LED, LOW);
  digitalWrite(SLEEP, HIGH);

  // Accélération rapide
  for (uint8_t j = 0; j < mappedValue; j++) {
    ledcWrite(LEDC_CHANNEL_1, j);
    delay(10);
  }
  
  delay(50);  // Courte pause
  
  // Décélération rapide
  for (uint8_t j = mappedValue; j > 0; j--) {
    ledcWrite(LEDC_CHANNEL_1, j);
    delay(10);
  }
  
  digitalWrite(SLEEP, LOW);
  
  // Court délai pour compléter exactement 1 seconde
  delay(100);
}

// Vérifie si une mise à jour est disponible
void checkForUpdates() {
  if (WiFi.status() != WL_CONNECTED) return;

  HTTPClient http;
  http.setFollowRedirects(HTTPC_STRICT_FOLLOW_REDIRECTS);
  http.setTimeout(30000);
  
  http.begin(VERSION_URL);
  int httpCode = http.GET();

  if (httpCode == HTTP_CODE_OK) {
    String payload = http.getString();
    JsonDocument doc;
    DeserializationError error = deserializeJson(doc, payload);
    
    if (error) {
      cdc.print("deserializeJson() failed: ");
      cdc.println(error.c_str());
      http.end();
      return;
    }

    if (doc.containsKey("version")) {
      const char* newVersion = doc["version"];
      cdc.print("Current version: ");
      cdc.print(CURRENT_VERSION);
      cdc.print(", Available version: ");
      cdc.println(newVersion);
      
      // Simple string comparison (assumes semantic versioning)
      if (strcmp(newVersion, CURRENT_VERSION) > 0) {
        updateAvailable = true;
        
        // Update firmware URL if provided
        if (doc.containsKey("url")) {
          firmwareUrlString = doc["url"].as<String>();
          FIRMWARE_URL = firmwareUrlString.c_str();
          cdc.print("Using firmware URL: ");
          cdc.println(FIRMWARE_URL);
        }
      }
    }
  }
  
  http.end();
  delay(3000); // Délai ajouté
}

// Télécharge et installe la mise à jour - FONCTION MODIFIÉE
bool downloadAndInstallUpdate() {
  if (WiFi.status() != WL_CONNECTED) return false;

  delay(3000);
  
  HTTPClient http;
  http.setFollowRedirects(HTTPC_FORCE_FOLLOW_REDIRECTS); // Mode FORCE pour meilleure prise en charge
  http.setTimeout(120000); // 2 minutes pour le téléchargement
  
  cdc.print("Connecting to firmware URL: ");
  cdc.println(FIRMWARE_URL);
  
  http.begin(FIRMWARE_URL);
  int httpCode = http.GET();
  
  cdc.print("HTTP response code: ");
  cdc.println(httpCode);

  if (httpCode != HTTP_CODE_OK) {
    cdc.print("Failed to download update! Error: ");
    cdc.println(http.errorToString(httpCode).c_str());
    http.end();
    return false;
  }

  int contentLength = http.getSize();
  if (contentLength <= 0) {
    cdc.println("Empty firmware file!");
    http.end();
    return false;
  }

  cdc.print("Firmware size: ");
  cdc.print(contentLength);
  cdc.println(" bytes");

  // Commencer la mise à jour
  if (!Update.begin(contentLength)) {
    cdc.println("Not enough space for update!");
    http.end();
    return false;
  }

  // Variables pour la vérification de signature
  bool signatureFound = false;
  WiFiClient *client = http.getStreamPtr();
  uint8_t buffer[128]; // Plus petit buffer pour éviter les problèmes de mémoire
  
  // Télécharger le firmware par blocs et l'installer
  int totalRead = 0;
  int readLength = 0;
  
  // Tampons pour rechercher la signature
  char signatureBuf[128]; // Buffer pour stocker des caractères consécutifs
  int bufPos = 0;
  memset(signatureBuf, 0, sizeof(signatureBuf));
  
  cdc.println("Starting download and installation...");
  
  while (totalRead < contentLength) {
    // Lire un bloc du firmware
    readLength = client->read(buffer, sizeof(buffer));
    
    if (readLength <= 0) {
      if (client->available()) {
        continue;
      } else {
        break;
      }
    }
    
    // Écrire le bloc dans la flash
    if (Update.write(buffer, readLength) != readLength) {
      cdc.println("Error writing firmware to flash!");
      Update.abort();
      http.end();
      return false;
    }
    
    totalRead += readLength;
    
    // Vérification de signature dans les premiers 16Ko seulement
    if (!signatureFound && totalRead < 16384) {
      // Convertir le buffer en caractères pour chercher la signature
      for (int i = 0; i < readLength; i++) {
        // Ajouter le caractère au buffer circulaire
        signatureBuf[bufPos] = (char)buffer[i];
        bufPos = (bufPos + 1) % (sizeof(signatureBuf) - 1);
        signatureBuf[bufPos] = '\0'; // Assurer la terminaison
        
        // Vérifier si le buffer contient la signature
        if (strstr(signatureBuf, UPDATE_SIGNATURE) != NULL) {
          signatureFound = true;
          cdc.println("Firmware signature found!");
          break;
        }
      }
    }
    
    // Afficher la progression toutes les 8Ko
    if (totalRead % 8192 == 0) {
      cdc.print("Downloaded and installed: ");
      cdc.print(totalRead);
      cdc.print(" of ");
      cdc.print(contentLength);
      cdc.println(" bytes");
    }
  }
  
  cdc.println("Download complete!");
  
  // Vérifier la signature
  if (!signatureFound) {
    cdc.println("Warning: Firmware signature not found!");
    // Continue quand même mais avec un avertissement
  }
  
  // Finaliser la mise à jour
  if (!Update.end()) {
    cdc.print("Update error: ");
    cdc.println(Update.errorString());
    http.end();
    return false;
  }
  
  if (Update.hasError()) {
    cdc.print("Update error: ");
    cdc.println(Update.errorString());
    http.end();
    return false;
  }

  cdc.println("Update successful!");
  http.end();
  return true;
}
